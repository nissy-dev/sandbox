# 作って学ぶ RDBMS の仕組み

## 1 章 : RDBMS を作ろう

- RDBMS のアーキテクチャ
  - クエリの構文解析
  - クエリプランナ
    - **実行計画の最適化・決定**
    - アクセスメソッドの呼び出し順とかを決める
    - SQL の`Explain` で一部をみることができる
  - クエリエクスキュータ
    - **アクセスメソッドの呼び出し**
    - 最適化された実行計画に基づき、アクセスメソッドを呼ぶ
  - アクセスメソッド
    - **テーブルのデータ構造をたどって、クエリエクスキュータの要求の結果を返す**
    - データ構造の探索をする、実際の読み書きは下のレイヤーにやらせる
  - バッファプールマネージャー
    - **データの塊をメモリにキャッシュ**
    - アクセスメソッドの要求に応じて、ディスクのデータの貸し出し
    - 基本的にキャッシュからデータを返す
  - ディスクマネージャー
    - **データの塊をディスクに書く・読む**
    - データの永続化を担う

## 2 章 : ディスクマネージャーの実装

- ディスクマネージャー
  - ヒープファイルを読み書きを担う
  - データを永続化するためには、データをファイルに書き込む必要がある
- ヒープファイル
  - ファイルを固定の長さ(バイト数)で区切ったもの
  - 区切った単位は「ページ」と呼ばれる、本では 4096 バイト
  - 必ずページ単位で読み書きする
    - 読みたい内容が 100 バイトでも 4096 バイト全てをとってくる
    - これは実際に HDD/SSD に内容を書き込む時にそうなっているから
    - ファイルマネージャーの仕様
- Rust 関連
  - AsRef：参照から参照への変換を担うトレイト
    - https://doc.rust-lang.org/std/convert/trait.AsRef.html
    - example をみる限り、面倒な型変換を無くしてくれそう
  - `#[derive(...)]`
    - 継承、特定のトレイトの標準的な実装を提供する
  - `#[repr(C)]`
    - メモリレイアウトの最適化をしない設定
  - `impl Trait`
    - Generics っぽく書いた方がわかりやすい
    - トレイトを実装した構造体を受け取るということ
    - https://doc.rust-jp.rs/book-ja/ch10-02-traits.html
      - 引数としてのトレイトのところに書いてあった
  - Seek : ファイルのカーソルを指定の位置へ移動させる
    - https://doc.rust-lang.org/stable/std/io/trait.Seek.html

## 3 章 : バッファプールマネージャーの実装

- バッファプールマネージャー
  - I/O 操作は遅いから、メモリにデータをキャッシュする
  - 独自のキャッシュ管理システムをもつ
    - ファイルシステムもキャッシュ機能を持っているが、DB 操作に最適化されていない
- Rust 関連
  - `Rc<T>`
    - `T`を使っているすべてのものが使い終わるまで、`T`には生存しててほしいタイミングなどに使える
    - 基本的に、Rust では値一つに対して所有者が一つで、不便なことも多い
  - `Default`
    - いい感じに初期値を入れてくれるやつ

## ４章 : B+Tree の観察

- B+Tree の概要の把握
  - 平衡 n 分木に分類されるデータ構造
  - リーフノードと中間ノードから成る
    - リーフノード
      - 末端ノードは必ずリーフノード
      - key-value のペアをもつ
      - 右のリーフノードに、左のリーフノードより小さいキーが含まれることはない
      - key でソートされている
    - 中間ノード
      - value は持たない、key と子ノードのポインタをもつ
      - 子ノードの key は、中間ノードの key より必ず小さくなっている
- RDBMS における B+Tree の利点
  - 検索・挿入・削除に関する操作が全て O(logN) でバランスが良い
    - 1 ページ = 1 ノードで管理
  - 範囲検索が得意
    - key でリーフノードがソートされているから

## 5 章 : テーブルの実装

- 主キー
  - テーブル内で行 (レコード) を一意に特定するための列 (カラム)
- 複合キー (複合主キー)
  - 複数の列を利用して、主キーを定義したもの
- テーブル作成
  - DB テーブルの実体である B+Tree を構築する
  - リーフノード
    - key-value 形式のデータをいくつか保持する
    - key : 主キー
    - value : 主キーに対応する行の内容をカンマで繋いだもの
  - １ページ = １リーフノード
  - ノード作成時に、バッファプールマネージャーの API も叩いている
    - ここら辺の解像度が少し低い...
- テーブル操作
  - 実行計画の組み合わせで表現
  - 実行計画 -> クエリエクスキュータ
  - 実行計画はテーブル操作の定義をする
  - クエリエクスキュータはそれに基づいて、B+Tree (テーブル) に対する操作の結果を返す (検索など)

## 6 章 : セカンダリインデックス

- セカンダリインデックス
  - 検索対象に対する主キーが格納されている
  - 料理本の例
    - 主キー : ページ番号
    - セカンダリインデックス : 料理名による索引
      - 料理名に対するページ番号 (主キー) が書かれている
  - 「インデックスをはる」とは、セカンダリインデックスを作成することっぽい
